extends Node2D
class_name DeckMaster

# Signal emitted when the scene catches the signal from Story Card. Should be
# caught by Game, which will then destroy this object.
signal done(owner)

# signal emitted when card is hidden
signal card_hidden(owner)

# Stores all employees present in the game
var employees

# Called when the node enters the scene tree for the first time.
func _ready():
	randomize()

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta):
	pass

# Return a filled out card generated by the Card Generator
func get_card() -> StoryCard:
	var card_dictionary = $CardGenerator.generate_card()
	var card: StoryCard = preload("res://card/story_card.tscn").instantiate()
	card.title = card_dictionary["title"]
	var employee_number = card_dictionary["employee_number"]
	var chosen_employees = choose_employees(employee_number, card_dictionary)
	card_dictionary = fill_employees(card_dictionary, chosen_employees)
	card.story_text = card_dictionary["text"]
	card.options = [card_dictionary["option1"], card_dictionary["option2"]]
	card.update_view()
	add_child(card)
	card.done.connect(_on_card_done)
	card.hidden.connect(_on_card_hidden)
	return card
	
# Pick random employees that will take part in the story
func choose_employees(number: int, card_dictionary: Dictionary) -> Array:
	var possible_e = possible_employees(card_dictionary)
	possible_e.shuffle()
	var chosen_employees =  possible_e.slice(0, number)
	return chosen_employees
	
# Return an array of employees that can take part in the story
# The conditions may be defined in the JSON file.
# TO BE IMPLEMENTED
func possible_employees(card_dictionary: Dictionary) -> Array:
	return employees.duplicate()
	
# Fill out the card dictionary with the chosen employees and return the modified
# dictionary
func fill_employees(card_dictionary: Dictionary, 
	chosen_employees: Array) -> Dictionary:
	var story_text : String = card_dictionary["text"]
	var options: Array[Dictionary] = [card_dictionary["option1"],
	card_dictionary["option2"]]
	for i in range(len(chosen_employees)):
		# Insert the names in the story text
		story_text = insert_employee_name(i, story_text, chosen_employees[i])
		# Replace the names and references in both options
		for j in range(2):
			options[j]["text"] = insert_employee_name(i, options[j]["text"],
			chosen_employees[i])
			for k in len(options[j]["effects"]):
				options[j]["effects"][k]["args"] = \
				insert_employee_ref(i, options[j]["effects"][k]["args"],
				chosen_employees[i])
	# Insert back and return the modified dict
	card_dictionary["text"] = story_text
	card_dictionary["options"] = [options[0], options[1]]
	return card_dictionary
	
# Insert employee name in string
func insert_employee_name(i: int, string: String, employee: Employee) -> String:
	return string.replace("${E" + str(i + 1) + "}.name", employee.name)

# Insert reference to employee in the args array
func insert_employee_ref(i: int, args: Array, employee: Employee) -> Array:
		for arg_set in args:	
			var index = arg_set.find("${E" + str(i + 1) + "}")
			while index != -1:
				arg_set[index] = employee
				index = arg_set.find("${E" + str(i + 1) + "}")
		return args

func _on_card_done(owner):
	emit_signal("done", self)
	owner.queue_free()
	
func _on_card_hidden():
	card_hidden.emit(self)
	
func has_card() -> bool:
	return get_child_count() > 1
